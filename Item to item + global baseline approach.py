# -*- coding: utf-8 -*-
"""Approach3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QwkQeW9i33BWSCbib66wL66TCubLHNCR
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn import metrics as met
from sklearn import neighbors as nei
from sklearn import decomposition as dec
from sklearn import manifold as man

df = pd.read_csv("train.csv")

df.head()

df.isnull().sum()

train = df.pivot(index="movieID", columns="userID", values="rating")
train.head()

meanall = df["rating"].mean()
meanall

test = pd.read_csv("test_without_labels.csv")
test.head()

testn = pd.DataFrame()
testn["userID"] = test["IDs"].str.split("_").apply(lambda x:x[0])
testn["movieID"] = test["IDs"].str.split("_").apply(lambda x:x[1])
testn.head()

train_scaled = train - train.mean(axis=0).values.reshape(1, -1)
train_scaled.fillna(0, inplace=True)
train_scaled.head()

sim_mat = met.pairwise.cosine_similarity(train_scaled.values)
sim_mat = pd.DataFrame(sim_mat, index=train_scaled.index, columns=train_scaled.index)
#sim_mat.shape

sim_mat.head()

preds = []
testusers = testn["userID"].values
#len(testusers)
for i in range(len(testusers)):
  userId = int(testusers[i])
  movie = int(testn.iloc[i,1])
  k = 22

  #calculating global baseline score
  meanmovie = train.loc[movie:movie, :].mean(axis=1).values[0]
  meanuser = train.loc[:, userId:userId].mean(axis=0).values[0]
  bx = meanmovie - meanall #deviation of mean of movie rating, from mean of all movie ratings
  bi = meanuser - meanall #deviation of mean of user rating, from mean of all movie ratings
  globalbaseline = meanall + bx + bi # global baseline scor for user i

  test_user = train_scaled.loc[movie:movie, :]

  filtered_indices = train[np.isnan(train.loc[:, userId]) == False].index
  filtered_train = train_scaled.loc[filtered_indices, :]

  if len(filtered_train) > 0:
    if len(filtered_train) < k:
      k = len(filtered_train)

    nn = nei.NearestNeighbors(n_neighbors=k, metric="cosine", algorithm="brute")
    nn.fit(filtered_train)
    close_indices = nn.kneighbors(test_user, return_distance=False)[0]

    userx = list(train.columns).index(userId)
    predmovie = list(train_scaled.index).index(movie) #found the index of the movie that I'm trying to  predict in the train data

    globaldev = 0
    sim_total = 0

    for j in close_indices:
      j_idx = filtered_train.iloc[j:j+1,:].index.values[0]
      r_xj = train.loc[j_idx,userId]
      sim_ij = sim_mat.loc[movie,j_idx] #close indices filtered traindeki j!!! o yüzden olmuyor. sim matrixi filtered train üzerinden tanımla

      meanmovie_j = train.loc[j_idx:j_idx, :].mean(axis=1).values[0]
      bx_j = meanmovie_j - meanall #deviation of mean of movie rating, from mean of all movie ratings
      globalbaseline_j = meanall + bx_j + bi # global baseline scor for user i

      globaldev += sim_ij*(r_xj-globalbaseline_j)
      sim_total += sim_ij
    if sim_total != 0:
      rating_xi = globalbaseline + globaldev/sim_total
    else:
      rating_xi = globalbaseline

    preds.append(rating_xi)

testnew = pd.concat([test,pd.Series(preds)],axis=1)
testnew = testnew.rename(columns={0:"rating"})
testnew.head()

testnew.to_csv("globalbaseline.csv", index=False)